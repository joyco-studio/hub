---
title: 04 - Context Is All You Need
author: 'matiasperz'
---

import { ComponentPreview } from '@/components/preview/component-preview'

## Why Use Context At All?

Most developers default to **prop drilling**, aka passing data through component props at every level. This works for simple cases, but breaks down quickly.

### The Prop Drilling Problem

```tsx
// Prop drilling: every component in the chain needs the props
function ProfilePage({ profile, currentUserId }) {
  const isOwner = profile.id === currentUserId
  const isAdmin = profile.role === "admin"
  
  return (
    <ProfileLayout profile={profile} isOwner={isOwner} isAdmin={isAdmin}>
      <ProfileHeader profile={profile} isOwner={isOwner} isAdmin={isAdmin} />
      <ProfileContent profile={profile} isOwner={isOwner}>
        <ProfileBio profile={profile} />
        <ProfileActions isOwner={isOwner} isAdmin={isAdmin} profileId={profile.id} />
      </ProfileContent>
    </ProfileLayout>
  )
}
```

**What's wrong with this?**
1. Every intermediate component must accept and forward props
2. Adding a new derived value means updating every component signature
3. Derived values (isOwner, isAdmin) recomputed or passed everywhere
4. Refactoring is painful - change one prop, update 10 files

### Context Solves This

```tsx
// With context: components grab what they need
function ProfilePage({ profile, currentUserId }) {
  return (
    <ProfileProvider profile={profile} currentUserId={currentUserId}>
      <ProfileLayout>
        <ProfileHeader />
        <ProfileContent>
          <ProfileBio />
          <ProfileActions />
        </ProfileContent>
      </ProfileLayout>
    </ProfileProvider>
  )
}

// Each component takes only what it needs
function ProfileActions() {
  const { isOwner, isAdmin, profile } = useProfileContext()
  // ...
}
```

---

## Now, What If We Want to Edit the Profile?

The `ProfileContext` above works great for viewing. But what happens when the user wants to **update their profile**?

**We need**:
- Form state (tracking what the user is typing)
- Change detection (has anything changed?)
- Validation (is the input valid?)
- Save/Reset actions
- Navigation guards (don't lose unsaved changes)

Should we add all this to `ProfileContext`? **No.** That would bloat our read-only context with concerns that only matter during editing.

Instead, we create a **separate context** for mutations:

| ProfileContext (Read-Only) | EditProfileContext (Form + Mutations) |
| --- | --- |
| Data from API | Form state |
| Computed/derived values | Change tracking |
| Permissions (isOwner, etc) | Validation |
| Used on ALL profile pages | Save/Reset/Delete |
| | Used only when editing |

This separation keeps each context focused on its responsibility.

---

## Example: ProfileContext (Read-Only)

Toggle between different user roles to see how context-derived values (`isOwner`, `isAdmin`) change what's rendered. The context computes these values once, and all child components access them directly.

<ComponentPreview name="profile-context-demo" />

---

## Example: EditProfileContext (Form + Mutations)

Edit the form fields to see change tracking, validation, and the save/reset flow in action. Notice how form state, validation errors, and actions are all managed through context.

<ComponentPreview name="edit-profile-context-demo" />

---

## Page Structure

```tsx
// View page
function ProfilePage({ profile, currentUserId }) {
  return (
    <ProfileProvider profile={profile} currentUserId={currentUserId}>
      <ProfileHeader />
      <ProfileBio />
      <ProfileActions />
    </ProfileProvider>
  )
}

// Edit page
function EditProfilePage({ profile, currentUserId }) {
  const router = useRouter()
  
  const handleSubmit = async (data) => {
    await updateProfile(profile.id, data)
    router.push(`/profile/${profile.id}`)
  }

  return (
    <ProfileProvider profile={profile} currentUserId={currentUserId}>
      <EditProfileProvider 
        initialData={{ name: profile.name, bio: profile.bio }}
        onSubmit={handleSubmit}
      >
        <EditProfileForm />
        <EditProfileActions />
      </EditProfileProvider>
    </ProfileProvider>
  )
}
```

---

## The Pattern in 4 Steps

### Step 1: Define your ViewContext

```tsx
type ViewContextType = {
  data: YourDataType
  // Computed values
  derivedValue1: boolean
  derivedValue2: string
}
```

### Step 2: Define your UpsertContext

```tsx
type UpsertContextType = {
  methods: UseFormReturn<FormState>
  hasChanges: boolean
  isSaving: boolean
  onSave: () => void
  onReset: () => void
}
```

### Step 3: Use ViewContext for all pages

```tsx
<ViewProvider data={data}>
  <ViewComponents />
</ViewProvider>
```

### Step 4: Wrap with UpsertContext for editing

```tsx
<ViewProvider data={data}>
  <UpsertProvider initialData={formData}>
    <EditComponents />
  </UpsertProvider>
</ViewProvider>
```

---

## Summary of Benefits

### Context vs Prop Drilling

| Benefit | How |
|---------|-----|
| **No prop threading** | Components grab what they need directly |
| **Derived values computed once** | Provider calculates, all consumers share |
| **Easy refactoring** | Add values to provider, use anywhere |
| **Consistent data** | Single source of truth for all components |

### Read-Only vs Upsert Separation

| Benefit | How |
|---------|-----|
| **Clear boundaries** | Reading vs writing clearly separated into two contexts |
| **Testability** | Each context can be tested independently |
| **Flexibility** | Components can use optional hooks to work in both viewing and editing |
| **Data protection** | Navigation guards and change tracking only where needed |

---

## When to Use This Pattern

**Use it when:**
- You have shared data/permissions needed by multiple components
- You want to avoid prop drilling through intermediate components
- You need computed/derived values used by multiple components
- You want clear separation between viewing and editing concerns

**Skip it when:**
- Very shallow component tree (2-3 levels)
- Data only used by a single component
- Simple CRUD with no viewing page (just list â†’ edit)
